import os
from collections import defaultdict
from datetime import datetime
from jinja2 import Environment, FileSystemLoader

from silvera.generator.registration import GeneratorDesc
from silvera.core import ServiceDecl, Function, FunctionParameter, MessageGroup, ConsumerAnnotation
from silvera.const import *

from csharpgen.type_converter import convert_type, convert_ret_type, get_default_for_cb_pattern
from csharpgen.utils import get_templates_path
from csharpgen.project_struct import create_if_missing, csharp_struct


def get_comment():
    return f"""
    Generated by: silvera
    Datetime: {datetime.now()}
"""


def first_upper(s: str):
    return s[0].upper() + s[1:]


def first_lower(s: str):
    return s[0].lower() + s[1:]


def param_names(func: Function):
    is_dto = len([p for p in func.params if not (p.url_placeholder or p.query_param)]) > 1
    return ", ".join(
        [p.name if p.url_placeholder or p.query_param or not is_dto
         else "request."+first_upper(p.name) for p in func.params])


def request_uri_and_body(func: Function):
    query_params, from_body = [], []
    post_or_put = func.http_verb == HTTP_POST or func.http_verb == HTTP_PUT
    for p in func.params:
        if p.query_param:
            query_params.append(p.name)
        elif p.url_placeholder:
            continue
        elif post_or_put:
            from_body.append(p.name)
        else:
            query_params.append(p.name)
    query_params_str = '?'+'&'.join([f'{{{n}.ToQueryString("{n}")}}' for n in query_params])
    from_body_str = from_body[0] if len(from_body) == 1 else f'new {{ {", ".join(from_body)} }}'
    request_uri = f'$"{func.rest_path.split("?")[0]}{query_params_str if query_params else ""}"'
    return f'{request_uri}, {from_body_str}' if post_or_put else request_uri


class ServiceGenerator:
    def __init__(self, service: ServiceDecl, output_dir):
        self.service = service
        self.templates_path = get_templates_path()
        self.env = self._init_env()
        self.main_path = csharp_struct(output_dir, service.name)

    def _init_env(self):
        env = Environment(loader=FileSystemLoader(self.templates_path))

        env.filters["first_upper"] = first_upper
        env.filters["first_lower"] = first_lower
        env.filters["convert_type"] = convert_type
        env.filters["convert_ret_type"] = convert_ret_type
        env.filters["unfold_function_params"] = \
            lambda f: ', '.join([f"{convert_type(p.type)} {p.name}" for p in f.params])
        env.filters["unfold_controller_function_params"] = self.unfold_controller_function_params
        env.filters["param_names"] = param_names
        env.filters["get_default_ret_val"] = get_default_for_cb_pattern
        env.filters["request_uri_and_body"] = request_uri_and_body

        env.globals["service_name"] = self.service.name
        env.globals["header_comment"] = get_comment

        return env

    def generate(self):
        self.generate_model()
        self.generate_repositories()
        if self.service.produces:
            self.generate_message_producer()
        if self.service.consumes:
            self.generate_message_consumer()
        self.generate_messages()
        self.generate_other_files()
        self.generate_controller()
        if self.service.dependencies:
            self.generate_dependency_services()
        self.generate_service()

    def generate_model(self):
        models_path = create_if_missing(os.path.join(self.main_path, "Models"))
        self.env.get_template("models/document.template").stream().dump(os.path.join(models_path, "IDocument.cs"))

        for typedef in self.service.api.typedefs:
            id_attr = None
            for attr in typedef.fields:
                if attr.isid:
                    id_attr = attr
            self.env.get_template("models/dataclass.template").stream({
                "dependency": False,
                "name": typedef.name,
                "attributes": typedef.fields,
                "id_attr": id_attr,
            }).dump(os.path.join(models_path, typedef.name + ".cs"))

        if not self.service.dep_typedefs:
            return
        dependencies_path = create_if_missing(os.path.join(models_path, "Dependencies"))

        for typedef in self.service.dep_typedefs:
            self.env.get_template("models/dataclass.template").stream({
                "dependency": True,
                "name": typedef.name,
                "attributes": typedef.fields,
            }).dump(os.path.join(dependencies_path, typedef.name + ".cs"))

    def generate_repositories(self):
        repo_path = create_if_missing(os.path.join(self.main_path, "Repository"))
        base_path = create_if_missing(os.path.join(repo_path, "Contracts"))
        impl_path = create_if_missing(os.path.join(repo_path, "Impl"))
        self.env.get_template("repository/i_repository.template").stream().dump(
            os.path.join(base_path, "IRepository.cs"))
        self.env.get_template("repository/repository.template").stream().dump(
            os.path.join(impl_path, "Repository.cs"))
        for typedef in self.service.api.typedefs:
            d = {"typedef": typedef.name}
            self.env.get_template("repository/iX_repository.template").stream(d).dump(
                os.path.join(base_path, f"I{typedef.name}Repository.cs"))
            self.env.get_template("repository/X_repository.template").stream(d).dump(
                os.path.join(impl_path, f"{typedef.name}Repository.cs"))

    def generate_message_producer(self):
        msg_path = create_if_missing(os.path.join(self.main_path, "Messaging"))
        messages_path = create_if_missing(os.path.join(msg_path, "Messages"))
        self.env.get_template("messaging/i_message.template").stream().dump(
            os.path.join(messages_path, "IMessage.cs"))
        self.env.get_template("messaging/producer.template").stream().dump(
            os.path.join(msg_path, "KafkaProducer.cs"))

    def generate_message_consumer(self):
        msg_path = create_if_missing(os.path.join(self.main_path, "Messaging"))
        messages_path = create_if_missing(os.path.join(msg_path, "Messages"))
        self.env.get_template("messaging/i_message.template").stream().dump(
            os.path.join(messages_path, "IMessage.cs"))
        self.env.get_template("messaging/consumer.template").stream().dump(
            os.path.join(msg_path, "KafkaConsumer.cs"))

    def generate_other_files(self):
        self.env.get_template("others/exceptions.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Exceptions")), "CustomExceptions.cs"))
        self.env.get_template("others/error_middleware.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Middleware")), "ErrorHandlerMiddleware.cs"))
        self.env.get_template("others/validate_model_attribute.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Filters")), "ValidateModelAttribute.cs"))

    def unfold_controller_function_params(self, func: Function):
        params, from_body = [], []
        for p in func.params:
            if p.url_placeholder:
                params.append(f"[FromRoute] {convert_type(p.type)} {p.name}")
            elif p.query_param:
                params.append(f"[FromQuery] {convert_type(p.type)} {p.name}")
            elif func.http_verb in {HTTP_POST, HTTP_PUT}:
                from_body.append(p)
            else:
                params.append(f"[FromQuery] {convert_type(p.type)} {p.name}")
                p.query_param = True
        if len(from_body) > 1:
            dto = self.generate_dto(first_upper(func.name)+"Request", from_body)
            params.append(f"[FromBody] {dto} request")
        elif from_body:
            params.append(f"[FromBody] {convert_type(from_body[0].type)} {from_body[0].name}")
        return ", ".join(params)

    def generate_dto(self, name: str, params: list[FunctionParameter]):
        dto_path = create_if_missing(os.path.join(self.main_path, "DTO"))
        self.env.get_template("controllers/dto.template").stream({
            "name": name,
            "fields": [(p.type, p.name) for p in params]
        }).dump(os.path.join(dto_path, name+".cs"))
        return name

    def generate_dependency_services(self):
        services_path = create_if_missing(os.path.join(self.main_path, "Services"))
        dep_path = create_if_missing(os.path.join(services_path, "Dependencies"))

        fns_by_service = defaultdict(list)
        use_circuit_breaker = False
        for fn in self.service.dep_functions:
            if fn.cb_pattern not in {None, "fail_fast"}:
                use_circuit_breaker = True
            fns_by_service[fn.service_name].append(fn)

        for s in self.service.dependencies:
            self.env.get_template("services/dependency_service.template").stream({
                "dependency_service_name": s.name,
                "functions": fns_by_service[s.name],
                "has_domain_dependencies": len(self.service.dep_typedefs) > 0,
                "use_circuit_breaker": use_circuit_breaker,
                "uses_registry": True if s.service_registry else False,
                "service_url": f"{s.url}:{s.port}"
            }).dump(os.path.join(dep_path, s.name + "Client.cs"))

    def generate_service(self):
        services_path = create_if_missing(os.path.join(self.main_path, "Services"))
        base_path = create_if_missing(os.path.join(services_path, "Base"))
        impl_path = create_if_missing(os.path.join(services_path, "Impl"))
        msg_per_function, function_per_channel = consumer_f(self.service)

        to_inject = [(f"I{t.name}Repository", f"{first_lower(t.name)}Repository") for t in self.service.api.typedefs]
        to_inject.extend([(f"I{d.name}Client", f"{first_lower(d.name)}Client") for d in self.service.dependencies])
        if self.service.produces:
            to_inject.append(("IKafkaProducer", "kafkaProducer"))
        self.service.uses_messaging
        service_data = {
            "service": self.service,
            "to_inject": to_inject,
            "constructor_params": ', '.join([f"{t} {name}" for t, name in to_inject]),
            "function_per_channel": function_per_channel,
            "msg_per_function": msg_per_function,
        }
        self.env.get_template("services/i_service.template").stream(service_data).dump(
            os.path.join(base_path, f"I{self.service.name}Service.cs"))
        impl_file = os.path.join(impl_path, f"{self.service.name}Service.cs")
        #if not os.path.exists(impl_file):
        self.env.get_template("services/service.template").stream(service_data).dump(impl_file)

    def generate_controller(self):
        controller_path = create_if_missing(os.path.join(self.main_path, "Controllers"))
        self.env.get_template("controllers/controller.template").stream({
            "api": self.service.api,
        }).dump(os.path.join(controller_path, self.service.name + "Controller.cs"))

    def generate_startup(self):
        self.env.get_template("startup.template").stream({
            "": None,
        }).dump(os.path.join(self.main_path, "Startup.cs"))

    def generate_settings(self):
        settings_path = create_if_missing(os.path.join(self.main_path, "Settings"))

    def generate_messages(self):
        msg_path = create_if_missing(os.path.join(self.main_path, "Messaging"))
        messages_path = create_if_missing(os.path.join(msg_path, "Messages"))

        def create_package(msg_group: MessageGroup, path: str, parent_ns="Messages"):
            curr_path = create_if_missing(os.path.join(path, msg_group.name))
            curr_ns = f"{parent_ns}.{msg_group.name}"
            for msg in msg_group.messages:
                self.env.get_template("messaging/message.template").stream({
                    "namespace": curr_ns,
                    "name": msg.name,
                    "fqn": msg.fqn,
                    "attributes": msg.fields
                }).dump(os.path.join(curr_path, msg.name+".cs"))

            for gr in msg_group.groups:
                create_package(gr, curr_path, curr_ns)

        for mg in self.service.parent.model.msg_pool.groups:
            create_package(mg, messages_path)

    def get_consumed_channels(self):
        return {ch for v in self.service.consumes.values() for ch in v}

    def check_messaging(self):
        channels = {}
        brokers = self.service.parent.model.msg_brokers
        for mb in brokers:
            for ch in brokers[mb].channels:
                if ch in channels:
                    raise Exception("Duplicate channel name found: ", ch)
            channels.update(brokers[mb].channels)
        print({ch.name: ch.msg_type.fqn for ch in channels.values()})
        print(self.service.consumers_per_message)
        print(self.service.f_consumers)
        print(self.service.consumes)
        print(consumer_f(self.service))
        print("PRODUCES:", self.service.produces)

        for m in self.service.consumes:
            for ch in self.service.consumes[m]:
                if ch.msg_type.fqn != m.fqn:
                    raise Exception(f"{self.service.name}: Cannot consume message of type {m.fqn} from channel "
                                    f"{ch.name}({ch.msg_type.fqn})")
        for m in self.service.produces:
            for ch in self.service.produces[m]:
                if isinstance(ch, set):
                    for ch1 in ch:
                        if ch1.msg_type.fqn != m.fqn:
                            raise Exception(f"{self.service.name}: Cannot produce message of type {m.fqn} to channel "
                                            f"{ch1.name}({ch1.msg_type.fqn})")
                    continue
                if ch.msg_type.fqn != m.fqn:
                    raise Exception(f"{self.service.name}: Cannot produce message of type {m.fqn} to channel "
                                    f"{ch.name}({ch.msg_type.fqn})")


def generate(service: ServiceDecl, output_dir, debug):
    print("Called C#!")
    print(service, output_dir)
    for d in service.dep_functions:
        print(d.name, d.ret_type)
    sg = ServiceGenerator(service, output_dir)
    sg.generate()

    mpf, fpc = consumer_f(sg.service)
    for ch in fpc:
        print(F"_{ch.name}Consumer = new KafkaConsumer<{ch.msg_type.fqn}>('{ch.name}');")
        for f in fpc[ch]:
            print(F"_{ch.name}Consumer.AddListener({f});")
        print()

    for f in mpf:
        for m in mpf[f]:
            print(f"void {f}({m} {m.lower()})")
        print()

    sg.check_messaging()


def consumer_f(service: ServiceDecl):
    mpf, fpc = defaultdict(set), defaultdict(set)
    internal = service.api.internal
    if not internal:
        return mpf, fpc
    for f in internal.functions:
        for ann in f.msg_annotations:
            if isinstance(ann, ConsumerAnnotation):
                for sub in ann.subscriptions:
                    mpf[f.name].add(sub.channel.msg_type.fqn)
                    fpc[sub.channel].add(f.name)
    return mpf, fpc


# Create C# generator.
csharp = GeneratorDesc(
    language_name="csharp",
    language_ver="10",
    description="C# 10 code generator",
    gen_func=generate
)
