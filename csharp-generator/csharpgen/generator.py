import os
from collections import defaultdict
from datetime import datetime
from jinja2 import Environment, FileSystemLoader

from silvera.generator.registration import GeneratorDesc
from silvera.core import ServiceDecl, Function, FunctionParameter
from silvera.const import *

from csharpgen.type_converter import convert_type, convert_ret_type, get_default_for_cb_pattern
from csharpgen.utils import get_templates_path
from csharpgen.project_struct import create_if_missing, csharp_struct


def get_comment():
    return f"""
    Generated by: silvera
    Datetime: {datetime.now()}
"""


def first_upper(s: str):
    return s[0].upper() + s[1:]


def first_lower(s: str):
    return s[0].lower() + s[1:]


def param_names(func: Function):
    is_dto = len([p for p in func.params if not (p.url_placeholder or p.query_param)]) > 1
    return ", ".join(
        [p.name if p.url_placeholder or p.query_param or not is_dto
         else "request."+first_upper(p.name) for p in func.params])


def request_uri_and_body(func: Function):
    query_params, from_body = [], []
    post_or_put = func.http_verb == HTTP_POST or func.http_verb == HTTP_PUT
    for p in func.params:
        if p.query_param:
            query_params.append(p.name)
        elif p.url_placeholder:
            continue
        elif post_or_put:
            from_body.append(p.name)
        else:
            query_params.append(p.name)
    query_params_str = '?'+'&'.join([f'{{{n}.ToQueryString("{n}")}}' for n in query_params])
    from_body_str = from_body[0] if len(from_body) == 1 else f'new {{ {", ".join(from_body)} }}'
    request_uri = f'$"{func.rest_path.split("?")[0]}{query_params_str if query_params else ""}"'
    return f'{request_uri}, {from_body_str}' if post_or_put else request_uri


class ServiceGenerator:
    def __init__(self, service: ServiceDecl, output_dir):
        self.service = service
        self.templates_path = get_templates_path()
        self.env = self._init_env()
        self.main_path = csharp_struct(output_dir, service.name)

    def _init_env(self):
        env = Environment(loader=FileSystemLoader(self.templates_path))

        env.filters["first_upper"] = first_upper
        env.filters["first_lower"] = first_lower
        env.filters["convert_type"] = convert_type
        env.filters["convert_ret_type"] = convert_ret_type
        env.filters["unfold_function_params"] = \
            lambda f: ', '.join([f"{convert_type(p.type)} {p.name}" for p in f.params])
        env.filters["unfold_controller_function_params"] = self.unfold_controller_function_params
        env.filters["param_names"] = param_names
        env.filters["get_default_ret_val"] = get_default_for_cb_pattern
        env.filters["request_uri_and_body"] = request_uri_and_body

        env.globals["service_name"] = self.service.name
        env.globals["header_comment"] = get_comment

        return env

    def generate(self):
        self.generate_model()
        self.generate_repositories()
        if self.service.produces:
            self.generate_message_producer()
        if self.service.consumes:
            self.generate_message_consumer()
        self.generate_other_files()
        self.generate_controller()
        self.generate_dependency_services()

    def generate_model(self):
        models_path = create_if_missing(os.path.join(self.main_path, "Models"))
        self.env.get_template("models/document.template").stream().dump(os.path.join(models_path, "IDocument.cs"))

        for typedef in self.service.api.typedefs:
            id_attr = None
            for attr in typedef.fields:
                if attr.isid:
                    id_attr = attr
            self.env.get_template("models/dataclass.template").stream({
                "dependency": False,
                "name": typedef.name,
                "attributes": typedef.fields,
                "id_attr": id_attr,
            }).dump(os.path.join(models_path, typedef.name + ".cs"))

        if not self.service.dep_typedefs:
            return
        dependencies_path = create_if_missing(os.path.join(models_path, "Dependencies"))

        for typedef in self.service.dep_typedefs:
            self.env.get_template("models/dataclass.template").stream({
                "dependency": True,
                "name": typedef.name,
                "attributes": typedef.fields,
            }).dump(os.path.join(dependencies_path, typedef.name + ".cs"))

    def generate_repositories(self):
        repo_path = create_if_missing(os.path.join(self.main_path, "Repository"))
        base_path = create_if_missing(os.path.join(repo_path, "Contracts"))
        impl_path = create_if_missing(os.path.join(repo_path, "Impl"))
        self.env.get_template("repository/i_repository.template").stream().dump(
            os.path.join(base_path, "IRepository.cs"))
        self.env.get_template("repository/repository.template").stream().dump(
            os.path.join(impl_path, "Repository.cs"))
        for typedef in self.service.api.typedefs:
            d = {"typedef": typedef.name}
            self.env.get_template("repository/iX_repository.template").stream(d).dump(
                os.path.join(base_path, f"I{typedef.name}Repository.cs"))
            self.env.get_template("repository/X_repository.template").stream(d).dump(
                os.path.join(impl_path, f"{typedef.name}Repository.cs"))

    def generate_message_producer(self):
        msg_path = create_if_missing(os.path.join(self.main_path, "Messaging"))
        messages_path = create_if_missing(os.path.join(msg_path, "Messages"))
        self.env.get_template("messaging/i_message.template").stream().dump(
            os.path.join(messages_path, "IMessage.cs"))
        self.env.get_template("messaging/producer.template").stream().dump(
            os.path.join(msg_path, "KafkaProducer.cs"))

    def generate_message_consumer(self):
        msg_path = create_if_missing(os.path.join(self.main_path, "Messaging"))
        messages_path = create_if_missing(os.path.join(msg_path, "Messages"))
        self.env.get_template("messaging/i_message.template").stream().dump(
            os.path.join(messages_path, "IMessage.cs"))
        self.env.get_template("messaging/consumer.template").stream().dump(
            os.path.join(msg_path, "KafkaConsumer.cs"))

    def generate_other_files(self):
        self.env.get_template("others/exceptions.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Exceptions")), "CustomExceptions.cs"))
        self.env.get_template("others/error_middleware.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Middleware")), "ErrorHandlerMiddleware.cs"))
        self.env.get_template("others/validate_model_attribute.template").stream().dump(
            os.path.join(create_if_missing(os.path.join(self.main_path, "Filters")), "ValidateModelAttribute.cs"))

    def unfold_controller_function_params(self, func: Function):
        params, from_body = [], []
        for p in func.params:
            if p.url_placeholder:
                params.append(f"[FromRoute] {convert_type(p.type)} {p.name}")
            elif p.query_param:
                params.append(f"[FromQuery] {convert_type(p.type)} {p.name}")
            elif func.http_verb in {HTTP_POST, HTTP_PUT}:
                from_body.append(p)
            else:
                params.append(f"[FromQuery] {convert_type(p.type)} {p.name}")
                p.query_param = True
        if len(from_body) > 1:
            dto = self.generate_dto(first_upper(func.name)+"Request", from_body)
            params.append(f"[FromBody] {dto} request")
        elif from_body:
            params.append(f"[FromBody] {convert_type(from_body[0].type)} {from_body[0].name}")
        return ", ".join(params)

    def generate_dto(self, name: str, params: list[FunctionParameter]):
        dto_path = create_if_missing(os.path.join(self.main_path, "DTO"))
        self.env.get_template("controllers/dto.template").stream({
            "name": name,
            "fields": [(p.type, p.name) for p in params]
        }).dump(os.path.join(dto_path, name+".cs"))
        return name

    def generate_dependency_services(self):
        services_path = create_if_missing(os.path.join(self.main_path, "Services"))
        dep_path = create_if_missing(os.path.join(services_path, "Dependencies"))

        fns_by_service = defaultdict(list)
        use_circuit_breaker = False
        for fn in self.service.dep_functions:
            if fn.cb_pattern not in {None, "fail_fast"}:
                use_circuit_breaker = True
            fns_by_service[fn.service_name].append(fn)

        for s in self.service.dependencies:
            self.env.get_template("services/dependency_service.template").stream({
                "dependency_service_name": s.name,
                "functions": fns_by_service[s.name],
                "has_domain_dependencies": len(self.service.dep_typedefs) > 0,
                "use_circuit_breaker": use_circuit_breaker,
                "uses_registry": True if s.service_registry else False,
                "service_url": f"{s.url}:{s.port}"
            }).dump(os.path.join(dep_path, s.name + "Client.cs"))

    def generate_service(self):
        services_path = create_if_missing(os.path.join(self.main_path, "Services"))
        base_path = create_if_missing(os.path.join(services_path, "Base"))
        impl_path = create_if_missing(os.path.join(services_path, "Impl"))

    def generate_controller(self):
        controller_path = create_if_missing(os.path.join(self.main_path, "Controllers"))
        self.env.get_template("controllers/controller.template").stream({
            "api": self.service.api,
        }).dump(os.path.join(controller_path, self.service.name + "Controller.cs"))

    def generate_startup(self):
        self.env.get_template("startup.template").stream({
            "": None,
        }).dump(os.path.join(self.main_path, "Startup.cs"))

    def generate_settings(self):
        settings_path = create_if_missing(os.path.join(self.main_path, "Settings"))


def generate(service: ServiceDecl, output_dir, debug):
    print("Called C#!")
    print(service, output_dir)
    for d in service.dep_functions:
        print(d.name, d.ret_type)
    ServiceGenerator(service, output_dir).generate()


# Create C# generator.
csharp = GeneratorDesc(
    language_name="csharp",
    language_ver="10",
    description="C# 10 code generator",
    gen_func=generate
)
